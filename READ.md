![Header](https://img.shields.io/badge/platform-iOS-lightgrey.svg)
![Header](https://img.shields.io/badge/completion-040/100-green.svg)

# 100DaysOfSwiftUI
100 Days Of SwiftUI Challenge by Paul Hudson -> https://www.hackingwithswift.com/100/swiftui

#
- [x] <b>Day 1</b>

1.</b> Introduction: Why Swift?

2.</b> Introduction: About this course
  
3.</b> Introduction: How to follow along
  
4.</b> How to create variables and constants
  -  Optional: Why does Swift have variables?
  -  Optional: Why does Swift have constants as well as variables?
  -  Test: Variables
  -  Test: Constants
    
5.</b> How to create strings
   -  Optional: Why does Swift need multi-line strings?
   -  Test: Multi-line strings
     
6.</b> How to store whole numbers
   -  Test: Strings and integers
     
7.</b> How to store decimal numbers
   -  Optional: Why does Swift need both Doubles and Integers?
 
  #
  - [x] <b>Day 2</b>
* How to store truth with Booleans
  -  Test: Doubles and Booleans
* How to join strings together
  -  Optional: Why does Swift have string interpolation?
  -  Test: String interpolation
* Summary: Simple data
  -  Checkpoint 1
 
  
  #
  - [x] <b>Day 3</b>
* How to store ordered data in arrays
  -  Optional: Why does Swift have arrays?
  -  Test: Arrays
    
* How to store and find data in dictionaries
  -  Optional: Why does Swift have dictionaries as well as arrays?
  -  Optional: Why does Swift have default values for dictionaries?
  -  Test: Dictionaries
  -  Test: Dictionary default values
    
* How to use sets for fast data lookup
  -  Optional: Why are sets different from arrays in Swift?
  -  Test: Sets
    
* How to create and use enums
  -  Optional: Why does Swift need enums?
  -  Test: Enumerations

  #
  - [x] <b>Day 4</b>
* How to use type annotations
  - Optional: Why does Swift have type annotations?
  - Optional: Why would you want to create an empty collection?
  - Test: Type annotations
    
* Summary: Complex data
  
* Checkpoint 2

  #
  - [x] <b>Day 5</b>
* How to check a condition is true or false
  - Optional: How does Swift let us compare many types of data?
* How to check multiple conditions
  - Optional: What’s the difference between if and else if?
  - Optional: How to check multiple conditions
  - Test: Conditions
  - Test: Combining conditions
* How to use switch statements to check multiple conditions
  - Optional: When should you use switch statements rather than if?
  - Test: Switch statements
* How to use the ternary conditional operator for quick tests
  - Optional: When should you use the ternary operator in Swift?
  - Test: The ternary operator
 

  #
  - [x] <b>Day 6</b>
* How to use a for loop to repeat work
  - Optional: Why does Swift use underscores with loops?
  - Optional: Why does Swift have two range operators?
  - Test: For loops
    
* How to use a while loop to repeat work
  - Optional: When should you use a while loop?
  - Test: While loops
    
* How to skip loop items with break and continue
  - Optional: Why would you want to exit a loop?
  - Optional: Why does Swift have labeled statements?
  - Optional: When to use break and when to use continue
  - Test: Exiting loops
 
* Summary: Conditions and loops
  
* Checkpoint 3



   #
   - [x] <b>Day 7</b>
 *  How to reuse code with functions
   - Optional: What code should be put in a function?
   - Optional: How many parameters should a function accept?
   - Test: Writing functions
   - Test: Accepting parameters
  
 * How to return values from functions
   - Optional: When is the return keyword not needed in a Swift function?
   - Test: Returning values
  
 * How to return multiple values from functions
   - Optional: Optional: When should you use an array, a set, or a tuple in Swift?
   - Test: Tuples
   - Test: Arrays vs sets vs tuples
  
 * How to customize parameter labels
    - Optional: When should you omit a parameter label?
    - Test: Omitting parameter labels
  



   #
   - [x] <b>Day 8</b>
 * How to provide default values for parameters
   - Optional: When to use default parameters for functions
   - Test: Default parameters
  
 * How to handle errors in functions
   - Optional: When should you write throwing functions?
   - Optional: Why does Swift make us use try before every throwing function?
   - Test: Writing throwing functions
   - Test: Running throwing functions

 * Summary: Functions

 * Checkpoint 4




   #
   - [x] <b>Day 9</b>
   
1.</b> How to create and use closures
   - Optional: What the heck are closures and why does Swift love them so much?
   - Optional: Why are Swift’s closure parameters inside the braces?
   - Optional: How do you return a value from a closure that takes no parameters?
   - Test: Creating basic closures
   - Test: Accepting parameters in a closure
   - Test: Returning values from a closure
  
2.</b> How to use trailing closures and shorthand syntax
   - Optional: Why does Swift have trailing closure syntax?
   - Optional: When should you use shorthand parameter names?
   - Test: Shorthand parameter names

3.</b> How to accept functions as parameters     
   - Optional: Why would you want to use closures as parameters?
   - Test: Closures as parameters
   - Test: Trailing closure syntax
    
4.</b> Summary: Closures  

5.</b> Checkpoint 5  



   #
   - [x] <b>Day 10</b>

 1.</b> How to create your own structs
  - Optional: What’s the difference between a struct and a tuple?
  - Optional: What’s the difference between a function and a method?
  - Optional: Why do we need to mark some methods as mutating?
  - Test: Structs
  - Test: Mutating methods

 2.</b> How to compute property values dynamically
  - Optional: When should you use a computed property or a stored property?
  - Test: Computed properties

 3.</b> How to take action when a property changes
  - Optional: When should you use property observers?
  - Optional: When should you use willSet rather than didSet?
  - Test: Property observers
    
 4.</b> How to create custom initializers
  - Optional: How do Swift’s memberwise initializers work?
  - Optional: When would you use self in a method?
  - Test: Initializers
  - Test: Referring to the current instance
 


   #
   - [x] <b>Day 11</b>

  1.</b> How to limit access to internal data using access control
   - Optional: What’s the point of access control?
   - Test: Access control
    
  2.</b> Static properties and methods 
   - Optional: What’s the point of static properties and methods in Swift?
   - Test: Static properties and methods

  3.</b> Summary: Structs

  4.</b> Checkpoint 6 


   #
   - [x] <b>Day 12</b>
   
  1.</b> How to create your own classes
   - Optional: Why does Swift have both classes and structs?
   - Optional: Why don’t Swift classes have a memberwise initializer?
   - Test: Creating your own classes
     

  2.</b> How to make one class inherit from another 
   - Optional: When would you want to override a method?
   - Optional: Which classes should be declared as final?


  3.</b> How to add initializers for classes  
   - Test: Class inheritance


  4.</b> How to copy classes 
   - Optional: Why do copies of a class share their data?
   - Test: Copying objects 


  5.</b> How to create a deinitializer for a class
   - Optional: Why do classes have deinitializers and structs don’t?
   - Test: Deinitializers


  6.</b> How to work with variables inside classes
   - Optional: Why can variable properties in constant classes be changed?
   - Test: Mutability


  7.</b> Summary: Classes    


  8.</b> Checkpoint 7


   #
   - [x] <b>Day 13</b>

   1.</b> How to create and use protocols
   - Optional: Why does Swift need protocols?
   - Test: Protocols

   2.</b> How to use opaque return types

   3.</b> How to create and use extensions 
   - Optional: When should you use extensions in Swift?
   - Test: Extensions


  4.</b> How to create and use protocol extensions
   - Optional: When are protocol extensions useful in Swift?
   - Test: Protocol extensions


  5.</b> Summary: Protocols and extensions

  6.</b> Checkpoint 8 


  
   #
   - [x] <b>Day 14</b>

   1.</b> How to handle missing data with optionals
   - Optional: Why does Swift have optionals?
   - Optional: Why does Swift make us unwrap optionals?
   - Test: Unwrapping optionals

   2.</b> How to unwrap optionals with guard
   - Optional: Why does Swift have optionals?
   - Test: Unwrapping with guard

   3.</b> How to unwrap optionals with nil coalescing
   - Optional: When should you use nil coalescing in Swift?
   - Test: Nil coalescing

   4.</b> How to handle multiple optionals using optional chaining
   - Optional: Why is optional chaining so important?
   - Test: Optional chaining 


   5.</b> How to handle function failure with optionals 
   - Optional: When should you use optional try?
   - Test: Optional try


   6.</b> Summary: Optionals

   7.</b> Checkpoint 9


  
   #
   - [x] <b>Day 15</b> Swift review 


  
   #
   - [x] <b>Day 16</b> Swift review

   - WeSplit: Introduction
   - Understanding the basic structure of a SwiftUI app
   - Creating a form
   - Adding a navigation bar
   - Modifying program state
   - Binding state to user interface controls
   - Creating views in a loop



   #
   - [x] <b>Day 17</b> Project 1, part two
   
   - Reading text from the user with TextField
   - Creating pickers in a form
   - Adding a segmented control for tip percentages
   - Calculating the total per person
   - Hiding the keyboard



   #
   - [x] <b>Day 18</b> Project 1, part three

   - WeSplit: Wrap up 
   - Review for Project 1: WeSplit


  
   #
   - [x] <b>Day 19</b> Challenge day 

   
  
   #
   - [x] <b>Day 20</b> Project 2, part 1
       
     - Guess the Flag: Introduction
     - Using stacks to arrange views
     - Colors and frames
     - Gradients
     - Buttons and images
     - Showing alert messages
       
   
  
   #
   - [x] <b>Day 21</b> Project 2, part two
       
     - Stacking up buttons
     - Showing the player’s score with an alert
     - Styling our flags
     - Upgrading our design 
       
   

  
   #
   - [x] <b>Day 22</b> Project 2, part three

     - Guess the Flag: Wrap up
     - Review for Project 2: Guess the Flag
              
   

  
   #
   - [x] <b>Day 23</b> Project 3, part one 

     - Views and modifiers: Introduction
     - Why does SwiftUI use structs for views?
     - What is behind the main SwiftUI view?
     - Why modifier order matters
     - Why does SwiftUI use “some View” for its view type?
     - Conditional modifiers
     - Environment modifiers 


   #
   - [x] <b>Day 24</b> Project 3, part two 

     - Views and modifiers: Wrap up
     - Review for Project 3: Views and Modifiers
        


   #
   - [x] <b>Day 25</b> Milestone: Projects 1-3

     - What you learned
     - Key points         


   #
   - [x] <b>Day 26</b> Project 4, part one

     - BetterRest: Introduction
     - Entering numbers with Stepper
     - Selecting dates and times with DatePicker
     - Working with dates
     - Training a model with Create ML
     

   #
   - [x] <b>Day 27</b> Project 4, part two
         
      - Building a basic layout
      - Connecting SwiftUI to Core ML
      - Cleaning up the user interface     

   #
   - [x] <b>Day 28</b> Project 4, part three
         
      - BetterRest: Wrap up
      - Review for Project 4: BetterRest
        
   #
   - [x] <b>Day 29</b> Project 5, part one
    
      - Word Scramble: Introduction 
      - Introducing List, your best friend
      - Loading resources from your app bundle
      - Working with strings
        
        
   #
   - [x] <b>Day 30</b> Project 5, part two

      - Adding to a list of words
      - Running code when our app launches
      - Validating words with UITextChecker
            
        
   #
   - [x] <b>Day 31</b> Project 5, part three

      - Review for Project 5: Word Scramble
      - Word Scramble: Wrap up            

        
   #
   - [x] <b>Day 32</b> Project 6, part one

      - Animation: Introduction
      - Creating implicit animations
      - Customizing animations in SwiftUI
      - Animating bindings
      - Creating explicit animations
        
                
   #
   - [x] <b>Day 33</b> Project 6, part two

      - Controlling the animation stack
      - Animating gestures
      - Showing and hiding views with transitions
      - Building custom transitions using ViewModifier
        
                
   #
   - [x] <b>Day 34</b> Project 6, part three

      - Animation: Wrap up
      - Review for Project 6: Animation
               
                
   #
   - [x] <b>Day 35</b> Milestone: Projects 4-6
 
      - What you learned
      - Key points
      - Challenge 
               
                
   #
   - [x] <b>Day 36</b> Project 7, part one

      - iExpense: Introduction
      - Using @State with classes
      - Sharing SwiftUI state with @Observable
      - Showing and hiding views
      - Deleting items using onDelete()
      - Storing user settings with UserDefaults
      - Archiving Swift objects with Codable
                       
                
   #
   - [x] <b>Day 37</b> Project 7, part two

      - Building a list we can delete from
      - Working with Identifiable items in SwiftUI
      - Sharing an observed object with a new view
      - Making changes permanent with UserDefaults
      - Final polish
                        
                
   #
   - [x] <b>Day 38</b> Project 7, part three

      - iExpense: Wrap up
      - Review for Project 7: iExpense
                           
                
   #
   - [x] <b>Day 39</b> Project 8, part one

      - Moonshot: Introduction
      - Resizing images to fit the available space
      - How ScrollView lets us work with scrolling data
      - Pushing new views onto the stack using NavigationLink
      - Working with hierarchical Codable data
      - How to lay out views in a scrolling grid
                           
                
   #
   - [x] <b>Day 40</b> Project 8, part two

      - Loading a specific kind of Codable data
      - Using generics to load any kind of Codable data
      - Formatting our mission view

